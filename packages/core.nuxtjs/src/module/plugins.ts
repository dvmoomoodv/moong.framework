import { isAbsolute, join, relative, resolve } from 'pathe'
import { genDynamicImport, genImport } from 'knitwork'
import escapeRE from 'escape-string-regexp'
import { logger } from '#ustra/nuxt/utils/logger'
import { objects, core } from '#ustra/core/utils'
import { useUstra } from '#ustra/nuxt/kit'
import { Nuxt, NuxtPlugin } from '@nuxt/schema'
import { addPluginTemplate, addTemplate, addPlugin } from '@nuxt/kit'
import { NuxtAppProps } from '../config/nuxt-app-props'

export const plugins = (options: NuxtAppProps, nuxt: Nuxt) => {
  logger.info('$ustra plugin to nuxt app')

  // add css
  nuxt.options.css.push('@ustra/nuxt/src/assets/styles/fonts.scss')

  addPluginTemplate({
    filename: 'ustra/ustra.ts',
    write: false,
    getContents() {
      const options = useUstra()
      const markdownImports = !options.nuxt.markdown.enabled
        ? ''
        : `
import '#ustra/nuxt/assets/styles/markdown.scss'
import 'highlight.js/styles/${options.nuxt.markdown.theme}.css'
`
      const tsImports = options.nuxt._build.pluginProps.map(p => {
        return {
          propName: p.propName,
          modulePath: p.moduleAlias,
        }
      })
      const pluginSubSets =
        options.nuxt._build.pluginProps.length < 1
          ? ''
          : `
  ${tsImports.map(p => `${genImport(p.modulePath, p.propName)}`).join(' \n  ')}
  ${tsImports.map(p => `addSubSets('${p.propName}', ${p.propName})`).join(' \n  ')}
`

      return ` // U.STRA Plugins
import plugin, { addSubSets } from '#ustra/nuxt/plugins/ustra'

${markdownImports}

// default font
// import '#ustra/nuxt/assets/styles/fonts.scss'

// tipppy
import 'tippy.js/dist/tippy.css'

// U.STRA plugin sub props
${pluginSubSets}

export default plugin
`
    },
  })

  // for sub plugin props
  addTemplate({
    filename: 'types/ustra.d.ts',
    getContents: () => {
      const EXTENSION_RE = new RegExp(`(?<=\\w)(${nuxt.options.extensions.map(e => escapeRE(e)).join('|')})$`, 'g')
      const tsImports = options.nuxt._build.pluginProps.map(p => {
        return {
          propName: p.propName,
          modulePath: (isAbsolute(p.modulePath) ? relative(join(nuxt.options.buildDir, 'types'), p.modulePath) : p.modulePath).replace(
            EXTENSION_RE,
            '',
          ),
        }
      })

      return `// Generated by U.STRA
type UstraPluginInjections = { \n  ${tsImports
        .map(p => `${p.propName}: typeof ${genDynamicImport(p.modulePath, { wrapper: false })}.default`)
        .join(' \n  ')}
}

declare module '@ustra/nuxt/src/plugins/ustra' {
interface Ustra extends UstraPluginInjections {}
}

declare module '#ustra/nuxt/plugins/ustra' {
interface Ustra extends UstraPluginInjections {}
}

export { }
  `
    },
    write: true,
  })

  nuxt.hook('prepare:types', ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, 'types/ustra.d.ts') })
  })

  const findIndexUstraPlugin = (plugins: (NuxtPlugin | string)[]) => {
    return plugins.findIndex(p => p['filename'] && p['filename'] === 'ustra/ustra.ts')
  }

  // sort plugins
  nuxt.hook('app:resolve', app => {
    // FIXME: 버전 변경 시마다 확인 필요함.
    // TODO: 플러그인 순서 변경 건 재확인 필요.
    if (app.plugins) {
      const ustraPluginIndex = findIndexUstraPlugin(app.plugins)
      // console.warn('ustraPluginIndex', ustraPluginIndex, app.plugins)

      app.plugins = app.plugins
        .map((plugin: any) => {
          return typeof plugin === 'string' ? { src: plugin } : plugin
        })
        .map((plugin, index) => {
          plugin.order = !core.isEmpty(plugin.order)
            ? plugin.order
            : plugin.filename === 'ustra/ustra.ts'
            ? 101
            : plugin.filename === 'ustra/ustra-vuetify.ts'
            ? 102
            : plugin.filename === 'ustra/ustra-wijmo.ts'
            ? 103
            : plugin.filename === 'ustra/ustra-dx.ts'
            ? 104
            : plugin.filename === 'ustra/ustra-ckeditor5.ts'
            ? 105
            : plugin.src && plugin.src.includes('@nuxtjs/i18n/dist/runtime/plugins/i18n')
            ? 110
            : plugin.src && plugin.src.includes('vuetify-nuxt-module')
            ? 111
            : // after plugins
            index > ustraPluginIndex
            ? 1000 + index
            : // plugin.src && plugin.src.includes('nuxt/dist/app/plugins/debug')
              // ? 1001
              // : plugin.src && plugin.src.includes('nuxt/dist/app/plugins/chunk-reload.client')
              // ? 1002
              // : plugin.src && plugin.src.includes('nuxt/dist/app/plugins/payload.client')
              // ? 1003
              // : plugin.src && plugin.src.includes('nuxt/dist/app/plugins/check-outdated-build.client')
              // ? 1004
              index
          return plugin
        })
        .sort((a, b) => a.order - b.order)
        // in nuxt3.8 get error when order properties exists
        .map(p => {
          delete p.order
          return p
        })

      // console.warn('ustraPluginIndex2', ustraPluginIndex, app.plugins)
    }
  })

  // for function app props
  const targetProps = ['nuxt.meta.auth.validateAuthentication']
  addTemplate({
    filename: 'ustra/app-props.ts',
    getContents: () => {
      const optionMap = {}

      for (const propPath of targetProps) {
        const value = objects.getPropertyFromPath(options, propPath)

        if (value && (typeof value === 'function' || value.constructor === RegExp)) {
          let fnStr = String(value)
            .replace(/require\(/gi, 'import(')
            .trim()
          const lastPathValue = propPath.split('.').splice(-1, 1)[0]

          const asyncStarter = `async ${lastPathValue}`
          if (fnStr.startsWith(asyncStarter)) {
            fnStr = `async function ${fnStr.substring(asyncStarter.length)}`
          }

          if (fnStr.startsWith(lastPathValue)) {
            fnStr = `function ${fnStr.substring(lastPathValue.length)}`
          }

          optionMap[propPath] = fnStr
        }
      }

      const optionMapStr = `{${Object.keys(optionMap)
        .map(key => `"${key}": ${optionMap[key]}`)
        .join(', ')}}`

      return `
        const optionMap = ${optionMapStr}

        const appProps = () => Promise.resolve(optionMap)
        export default appProps
      `
    },
    options,
    write: true,
  })
}
